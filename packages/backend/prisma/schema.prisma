datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                         String    @id @default(cuid())
  email                      String    @unique
  passwordHash               String    @map("password_hash")
  firstName                  String    @map("first_name")
  lastName                   String    @map("last_name")
  isAdmin                    Boolean   @default(false) @map("is_admin")
  timezone                   String    @default("Europe/Madrid")
  isEmailVerified            Boolean   @default(false) @map("is_email_verified")
  emailVerificationToken     String?   @unique @map("email_verification_token")
  emailVerificationExpiresAt DateTime? @map("email_verification_expires_at")
  createdAt                  DateTime  @default(now()) @map("created_at")
  updatedAt                  DateTime  @updatedAt @map("updated_at")

  slots                    AvailabilitySlot[]
  bookings                 Booking[]
  notesWritten             StudentNote[]      @relation("NotesWritten")
  notesReceived            StudentNote[]      @relation("NotesReceived")
  allowedSlots             SlotAllowedStudent[]
  recurringPatterns        RecurringPattern[]
  allowedRecurringPatterns RecurringPatternAllowedStudent[]

  @@map("users")
}

model AvailabilitySlot {
  id                  String     @id @default(cuid())
  professorId         String     @map("professor_id")
  startTime           DateTime   @map("start_time")
  endTime             DateTime   @map("end_time")
  slotType            SlotType   @default(INDIVIDUAL) @map("slot_type")
  maxParticipants     Int        @default(1) @map("max_participants")
  currentParticipants Int        @default(0) @map("current_participants")
  status              SlotStatus @default(AVAILABLE)
  title               String?
  description         String?    @db.Text
  meetingRoomName     String?    @map("meeting_room_name") // Immutable Jitsi room name
  isPrivate           Boolean    @default(false) @map("is_private")
  recurringPatternId  String?    @map("recurring_pattern_id")
  createdAt           DateTime   @default(now()) @map("created_at")
  updatedAt           DateTime   @updatedAt @map("updated_at")

  professor        User              @relation(fields: [professorId], references: [id])
  bookings         Booking[]
  allowedStudents  SlotAllowedStudent[]
  recurringPattern RecurringPattern? @relation(fields: [recurringPatternId], references: [id])

  @@index([professorId])
  @@index([startTime])
  @@index([recurringPatternId])
  @@map("availability_slots")
}

model SlotAllowedStudent {
  id        String   @id @default(cuid())
  slotId    String   @map("slot_id")
  studentId String   @map("student_id")
  createdAt DateTime @default(now()) @map("created_at")

  slot    AvailabilitySlot @relation(fields: [slotId], references: [id], onDelete: Cascade)
  student User             @relation(fields: [studentId], references: [id])

  @@unique([slotId, studentId])
  @@index([studentId])
  @@map("slot_allowed_students")
}

model RecurringPattern {
  id           String   @id @default(cuid())
  professorId  String   @map("professor_id")
  title        String?
  description  String?  @db.Text
  slotType     SlotType @default(INDIVIDUAL) @map("slot_type")
  maxParticipants Int   @default(1) @map("max_participants")
  daysOfWeek   String   @map("days_of_week") // JSON array: [1, 2, 3] for Mon, Tue, Wed
  startTime    String   @map("start_time") // "10:00" format
  endTime      String   @map("end_time") // "11:00" format
  startDate    DateTime @map("start_date")
  endDate      DateTime? @map("end_date") // null = indefinite
  isPrivate    Boolean  @default(false) @map("is_private")
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  professor    User               @relation(fields: [professorId], references: [id])
  slots        AvailabilitySlot[]
  allowedStudents RecurringPatternAllowedStudent[]

  @@index([professorId])
  @@map("recurring_patterns")
}

model RecurringPatternAllowedStudent {
  id                 String   @id @default(cuid())
  recurringPatternId String   @map("recurring_pattern_id")
  studentId          String   @map("student_id")
  createdAt          DateTime @default(now()) @map("created_at")

  recurringPattern RecurringPattern @relation(fields: [recurringPatternId], references: [id], onDelete: Cascade)
  student          User             @relation(fields: [studentId], references: [id])

  @@unique([recurringPatternId, studentId])
  @@index([studentId])
  @@map("recurring_pattern_allowed_students")
}

model Booking {
  id                     String        @id @default(cuid())
  slotId                 String        @map("slot_id")
  studentId              String        @map("student_id")
  status                 BookingStatus @default(CONFIRMED)
  bookedAt               DateTime      @default(now()) @map("booked_at")
  cancelledAt            DateTime?     @map("cancelled_at")
  cancelReason           String?       @map("cancel_reason")
  bookedCalendarEventId  String?       @map("booked_calendar_event_id")
  createdAt              DateTime      @default(now()) @map("created_at")
  updatedAt              DateTime      @updatedAt @map("updated_at")

  slot    AvailabilitySlot @relation(fields: [slotId], references: [id])
  student User             @relation(fields: [studentId], references: [id])

  @@unique([slotId, studentId])
  @@index([studentId])
  @@map("bookings")
}

model StudentNote {
  id          String   @id @default(cuid())
  professorId String   @map("professor_id")
  studentId   String   @map("student_id")
  content     String   @db.Text
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  professor User @relation("NotesWritten", fields: [professorId], references: [id])
  student   User @relation("NotesReceived", fields: [studentId], references: [id])

  @@index([professorId, studentId])
  @@map("student_notes")
}

enum SlotType {
  INDIVIDUAL
  GROUP
}

enum SlotStatus {
  AVAILABLE
  FULLY_BOOKED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum BookingStatus {
  CONFIRMED
  CANCELLED_BY_STUDENT
  CANCELLED_BY_PROFESSOR
  COMPLETED
  NO_SHOW
}

model EmailLog {
  id          String   @id @default(cuid())
  emailType   String   @map("email_type") // booking_confirmation, cancellation, etc.
  fromAddress String   @map("from_address")
  toAddress   String   @map("to_address")
  subject     String
  htmlContent String   @map("html_content") @db.Text
  status      String   @default("sent") // sent, failed
  error       String?  @db.Text
  metadata    String?  @db.Text // JSON string with additional context
  createdAt   DateTime @default(now()) @map("created_at")

  @@index([createdAt])
  @@index([toAddress])
  @@index([emailType])
  @@map("email_logs")
}
